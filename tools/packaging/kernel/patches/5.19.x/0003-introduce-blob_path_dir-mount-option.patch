From 26815825cf847f947dae14dab69b7f1311ff9b82 Mon Sep 17 00:00:00 2001
From: Leospard <694963063@qq.com>
Date: Mon, 25 Sep 2023 01:28:07 +0800
Subject: [PATCH 3/3] introduce blob_path_dir mount option

---
 fs/erofs/data.c     |   2 +
 fs/erofs/internal.h |  68 ++--
 fs/erofs/super.c    | 837 ++++++++++++++++++++++++--------------------
 3 files changed, 516 insertions(+), 391 deletions(-)

diff --git a/fs/erofs/data.c b/fs/erofs/data.c
index 1fc53b2b8..1519ca65b 100644
--- a/fs/erofs/data.c
+++ b/fs/erofs/data.c
@@ -245,6 +245,7 @@ int erofs_map_dev(struct super_block *sb, struct erofs_map_dev *map)
 			return -ENODEV;
 		}
 		map->m_bdev = dif->bdev;
+		map->m_fp = dif->blobfile;
 		map->m_daxdev = dif->dax_dev;
 		map->m_dax_part_off = dif->dax_part_off;
 		map->m_fscache = dif->fscache;
@@ -267,6 +268,7 @@ int erofs_map_dev(struct super_block *sb, struct erofs_map_dev *map)
 			{
 				map->m_pa -= startoff;
 				map->m_bdev = dif->bdev;
+				map->m_fp = dif->blobfile;
 				map->m_daxdev = dif->dax_dev;
 				map->m_dax_part_off = dif->dax_part_off;
 				map->m_fscache = dif->fscache;
diff --git a/fs/erofs/internal.h b/fs/erofs/internal.h
index 0710c3d71..f0244c3c9 100644
--- a/fs/erofs/internal.h
+++ b/fs/erofs/internal.h
@@ -47,10 +47,12 @@ typedef u64 erofs_off_t;
 /* data type for filesystem-wide blocks number */
 typedef u32 erofs_blk_t;
 
-struct erofs_device_info {
+struct erofs_device_info
+{
 	char *path;
 	struct erofs_fscache *fscache;
 	struct block_device *bdev;
+	struct file *blobfile;
 	struct dax_device *dax_dev;
 	u64 dax_part_off;
 
@@ -58,13 +60,15 @@ struct erofs_device_info {
 	u32 mapped_blkaddr;
 };
 
-enum {
+enum
+{
 	EROFS_SYNC_DECOMPRESS_AUTO,
 	EROFS_SYNC_DECOMPRESS_FORCE_ON,
 	EROFS_SYNC_DECOMPRESS_FORCE_OFF
 };
 
-struct erofs_mount_opts {
+struct erofs_mount_opts
+{
 #ifdef CONFIG_EROFS_FS_ZIP
 	/* current strategy of how to use managed cache */
 	unsigned char cache_strategy;
@@ -78,33 +82,39 @@ struct erofs_mount_opts {
 	char *fsid;
 };
 
-struct erofs_dev_context {
+struct erofs_dev_context
+{
 	struct idr tree;
 	struct rw_semaphore rwsem;
 
 	unsigned int extra_devices;
 };
 
-struct erofs_fs_context {
+struct erofs_fs_context
+{
 	struct erofs_mount_opts opt;
 	struct erofs_dev_context *devs;
 	char *bootstrap_path;
+	char *blob_dir_path;
 };
 
 /* all filesystem-wide lz4 configurations */
-struct erofs_sb_lz4_info {
+struct erofs_sb_lz4_info
+{
 	/* # of pages needed for EROFS lz4 rolling decompression */
 	u16 max_distance_pages;
 	/* maximum possible blocks for pclusters in the filesystem */
 	u16 max_pclusterblks;
 };
 
-struct erofs_fscache {
+struct erofs_fscache
+{
 	struct fscache_cookie *cookie;
 	struct inode *inode;
 };
 
-struct erofs_sb_info {
+struct erofs_sb_info
+{
 	struct erofs_mount_opts opt; /* options */
 #ifdef CONFIG_EROFS_FS_ZIP
 	/* list for all registered superblocks, mainly for shrinker */
@@ -122,8 +132,11 @@ struct erofs_sb_info {
 
 	struct erofs_sb_lz4_info lz4;
 #endif /* CONFIG_EROFS_FS_ZIP */
+	struct path blob_dir;
 	struct file *bootstrap;
+	char *blob_dir_path;
 	char *bootstrap_path;
+
 	struct erofs_dev_context *devs;
 	struct dax_device *dax_dev;
 	u64 dax_part_off;
@@ -175,11 +188,13 @@ struct erofs_sb_info {
 #define set_opt(opt, option) ((opt)->mount_opt |= EROFS_MOUNT_##option)
 #define test_opt(opt, option) ((opt)->mount_opt & EROFS_MOUNT_##option)
 
-static inline bool erofs_is_fscache_mode(struct super_block *sb) {
+static inline bool erofs_is_fscache_mode(struct super_block *sb)
+{
 	return IS_ENABLED(CONFIG_EROFS_FS_ONDEMAND) && !sb->s_bdev;
 }
 
-enum {
+enum
+{
 	EROFS_ZIP_CACHE_DISABLED,
 	EROFS_ZIP_CACHE_READAHEAD,
 	EROFS_ZIP_CACHE_READAROUND
@@ -189,7 +204,8 @@ enum {
 #define EROFS_LOCKED_MAGIC (INT_MIN | 0xE0F510CCL)
 
 /* basic unit of the workstation of a super_block */
-struct erofs_workgroup {
+struct erofs_workgroup
+{
 	/* the workgroup index in the workstation */
 	pgoff_t index;
 
@@ -198,9 +214,11 @@ struct erofs_workgroup {
 };
 
 static inline bool erofs_workgroup_try_to_freeze(struct erofs_workgroup *grp,
-												 int val) {
+												 int val)
+{
 	preempt_disable();
-	if (val != atomic_cmpxchg(&grp->refcount, val, EROFS_LOCKED_MAGIC)) {
+	if (val != atomic_cmpxchg(&grp->refcount, val, EROFS_LOCKED_MAGIC))
+	{
 		preempt_enable();
 		return false;
 	}
@@ -208,7 +226,8 @@ static inline bool erofs_workgroup_try_to_freeze(struct erofs_workgroup *grp,
 }
 
 static inline void erofs_workgroup_unfreeze(struct erofs_workgroup *grp,
-											int orig_val) {
+											int orig_val)
+{
 	/*
 	 * other observers should notice all modifications
 	 * in the freezing period.
@@ -218,7 +237,8 @@ static inline void erofs_workgroup_unfreeze(struct erofs_workgroup *grp,
 	preempt_enable();
 }
 
-static inline int erofs_wait_on_workgroup_freezed(struct erofs_workgroup *grp) {
+static inline int erofs_wait_on_workgroup_freezed(struct erofs_workgroup *grp)
+{
 	return atomic_cond_read_relaxed(&grp->refcount,
 									VAL != EROFS_LOCKED_MAGIC);
 }
@@ -239,13 +259,15 @@ static inline int erofs_wait_on_workgroup_freezed(struct erofs_workgroup *grp) {
 #error erofs cannot be used in this platform
 #endif
 
-enum erofs_kmap_type {
+enum erofs_kmap_type
+{
 	EROFS_NO_KMAP,	   /* don't map the buffer */
 	EROFS_KMAP,		   /* use kmap() to map the buffer */
 	EROFS_KMAP_ATOMIC, /* use kmap_atomic() to map the buffer */
 };
 
-struct erofs_buf {
+struct erofs_buf
+{
 	struct page *page;
 	void *base;
 	enum erofs_kmap_type kmap_type;
@@ -258,7 +280,8 @@ struct erofs_buf {
 #define erofs_blkoff(addr) ((addr) % EROFS_BLKSIZ)
 #define blknr_to_addr(nr) ((erofs_off_t)(nr)*EROFS_BLKSIZ)
 
-static inline erofs_off_t iloc(struct erofs_sb_info *sbi, erofs_nid_t nid) {
+static inline erofs_off_t iloc(struct erofs_sb_info *sbi, erofs_nid_t nid)
+{
 	return blknr_to_addr(sbi->meta_blkaddr) + (nid << sbi->islotbits);
 }
 
@@ -285,7 +308,8 @@ EROFS_FEATURE_FUNCS(sb_chksum, compat, COMPAT_SB_CHKSUM)
 #define EROFS_I_BL_XATTR_BIT (BITS_PER_LONG - 1)
 #define EROFS_I_BL_Z_BIT (BITS_PER_LONG - 2)
 
-struct erofs_inode {
+struct erofs_inode
+{
 	erofs_nid_t nid;
 
 	/* atomic flags (including bitlocks) */
@@ -325,13 +349,15 @@ struct erofs_inode {
 #define EROFS_I(ptr) \
 	container_of(ptr, struct erofs_inode, vfs_inode)
 
-static inline unsigned long erofs_inode_datablocks(struct inode *inode) {
+static inline unsigned long erofs_inode_datablocks(struct inode *inode)
+{
 	/* since i_size cannot be changed */
 	return DIV_ROUND_UP(inode->i_size, EROFS_BLKSIZ);
 }
 
 static inline unsigned int erofs_bitrange(unsigned int value, unsigned int bit,
-										  unsigned int bits) {
+										  unsigned int bits)
+{
 
 	return (value >> bit) & ((1 << bits) - 1);
 }
diff --git a/fs/erofs/super.c b/fs/erofs/super.c
index bd43edf02..894fa16b5 100644
--- a/fs/erofs/super.c
+++ b/fs/erofs/super.c
@@ -6,6 +6,7 @@
  */
 #include <linux/module.h>
 #include <linux/buffer_head.h>
+#include <linux/namei.h>
 #include <linux/statfs.h>
 #include <linux/parser.h>
 #include <linux/seq_file.h>
@@ -22,7 +23,7 @@
 static struct kmem_cache *erofs_inode_cachep __read_mostly;
 
 void _erofs_err(struct super_block *sb, const char *function,
-		const char *fmt, ...)
+				const char *fmt, ...)
 {
 	struct va_format vaf;
 	va_list args;
@@ -37,7 +38,7 @@ void _erofs_err(struct super_block *sb, const char *function,
 }
 
 void _erofs_info(struct super_block *sb, const char *function,
-		 const char *fmt, ...)
+				 const char *fmt, ...)
 {
 	struct va_format vaf;
 	va_list args;
@@ -57,7 +58,7 @@ static int erofs_superblock_csum_verify(struct super_block *sb, void *sbdata)
 	u32 expected_crc, crc;
 
 	dsb = kmemdup(sbdata + EROFS_SUPER_OFFSET,
-		      EROFS_BLKSIZ - EROFS_SUPER_OFFSET, GFP_KERNEL);
+				  EROFS_BLKSIZ - EROFS_SUPER_OFFSET, GFP_KERNEL);
 	if (!dsb)
 		return -ENOMEM;
 
@@ -67,9 +68,10 @@ static int erofs_superblock_csum_verify(struct super_block *sb, void *sbdata)
 	crc = crc32c(~0, dsb, EROFS_BLKSIZ - EROFS_SUPER_OFFSET);
 	kfree(dsb);
 
-	if (crc != expected_crc) {
+	if (crc != expected_crc)
+	{
 		erofs_err(sb, "invalid checksum 0x%08x, 0x%08x expected",
-			  crc, expected_crc);
+				  crc, expected_crc);
 		return -EBADMSG;
 	}
 	return 0;
@@ -108,17 +110,18 @@ static void erofs_free_inode(struct inode *inode)
 }
 
 static bool check_layout_compatibility(struct super_block *sb,
-				       struct erofs_super_block *dsb)
+									   struct erofs_super_block *dsb)
 {
 	const unsigned int feature = le32_to_cpu(dsb->feature_incompat);
 
 	EROFS_SB(sb)->feature_incompat = feature;
 
 	/* check if current kernel meets all mandatory requirements */
-	if (feature & (~EROFS_ALL_FEATURE_INCOMPAT)) {
+	if (feature & (~EROFS_ALL_FEATURE_INCOMPAT))
+	{
 		erofs_err(sb,
-			  "unidentified incompatible feature %x, please upgrade kernel version",
-			   feature & ~EROFS_ALL_FEATURE_INCOMPAT);
+				  "unidentified incompatible feature %x, please upgrade kernel version",
+				  feature & ~EROFS_ALL_FEATURE_INCOMPAT);
 		return false;
 	}
 	return true;
@@ -127,7 +130,7 @@ static bool check_layout_compatibility(struct super_block *sb,
 #ifdef CONFIG_EROFS_FS_ZIP
 /* read variable-sized metadata, offset will be aligned by 4-byte */
 static void *erofs_read_metadata(struct super_block *sb, struct erofs_buf *buf,
-				 erofs_off_t *offset, int *lengthp)
+								 erofs_off_t *offset, int *lengthp)
 {
 	u8 *buffer, *ptr;
 	int len, i, cnt;
@@ -146,11 +149,13 @@ static void *erofs_read_metadata(struct super_block *sb, struct erofs_buf *buf,
 	*offset += sizeof(__le16);
 	*lengthp = len;
 
-	for (i = 0; i < len; i += cnt) {
+	for (i = 0; i < len; i += cnt)
+	{
 		cnt = min(EROFS_BLKSIZ - (int)erofs_blkoff(*offset), len - i);
 		ptr = erofs_read_metabuf(buf, sb, erofs_blknr(*offset),
-					 EROFS_KMAP);
-		if (IS_ERR(ptr)) {
+								 EROFS_KMAP);
+		if (IS_ERR(ptr))
+		{
 			kfree(buffer);
 			return ptr;
 		}
@@ -161,7 +166,7 @@ static void *erofs_read_metadata(struct super_block *sb, struct erofs_buf *buf,
 }
 
 static int erofs_load_compr_cfgs(struct super_block *sb,
-				 struct erofs_super_block *dsb)
+								 struct erofs_super_block *dsb)
 {
 	struct erofs_sb_info *sbi = EROFS_SB(sb);
 	struct erofs_buf buf = __EROFS_BUF_INITIALIZER;
@@ -170,27 +175,31 @@ static int erofs_load_compr_cfgs(struct super_block *sb,
 	int size, ret = 0;
 
 	sbi->available_compr_algs = le16_to_cpu(dsb->u1.available_compr_algs);
-	if (sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS) {
+	if (sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS)
+	{
 		erofs_err(sb, "try to load compressed fs with unsupported algorithms %x",
-			  sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS);
+				  sbi->available_compr_algs & ~Z_EROFS_ALL_COMPR_ALGS);
 		return -EINVAL;
 	}
 
 	offset = EROFS_SUPER_OFFSET + sbi->sb_size;
 	alg = 0;
-	for (algs = sbi->available_compr_algs; algs; algs >>= 1, ++alg) {
+	for (algs = sbi->available_compr_algs; algs; algs >>= 1, ++alg)
+	{
 		void *data;
 
 		if (!(algs & 1))
 			continue;
 
 		data = erofs_read_metadata(sb, &buf, &offset, &size);
-		if (IS_ERR(data)) {
+		if (IS_ERR(data))
+		{
 			ret = PTR_ERR(data);
 			break;
 		}
 
-		switch (alg) {
+		switch (alg)
+		{
 		case Z_EROFS_COMPRESSION_LZ4:
 			ret = z_erofs_load_lz4_config(sb, dsb, data, size);
 			break;
@@ -210,9 +219,10 @@ static int erofs_load_compr_cfgs(struct super_block *sb,
 }
 #else
 static int erofs_load_compr_cfgs(struct super_block *sb,
-				 struct erofs_super_block *dsb)
+								 struct erofs_super_block *dsb)
 {
-	if (dsb->u1.available_compr_algs) {
+	if (dsb->u1.available_compr_algs)
+	{
 		erofs_err(sb, "try to load compressed fs when compression is disabled");
 		return -EINVAL;
 	}
@@ -221,7 +231,7 @@ static int erofs_load_compr_cfgs(struct super_block *sb,
 #endif
 
 static int erofs_init_device(struct erofs_buf *buf, struct super_block *sb,
-			     struct erofs_device_info *dif, erofs_off_t *pos)
+							 struct erofs_device_info *dif, erofs_off_t *pos)
 {
 	struct erofs_sb_info *sbi = EROFS_SB(sb);
 	struct erofs_deviceslot *dis;
@@ -234,8 +244,10 @@ static int erofs_init_device(struct erofs_buf *buf, struct super_block *sb,
 		return PTR_ERR(ptr);
 	dis = ptr + erofs_blkoff(*pos);
 
-	if (!dif->path) {
-		if (!dis->tag[0]) {
+	if (!dif->path)
+	{
+		if (!dis->tag[0])
+		{
 			erofs_err(sb, "empty device tag @ pos %llu", *pos);
 			return -EINVAL;
 		}
@@ -244,14 +256,30 @@ static int erofs_init_device(struct erofs_buf *buf, struct super_block *sb,
 			return -ENOMEM;
 	}
 
-	if (erofs_is_fscache_mode(sb)) {
+	if (erofs_is_fscache_mode(sb))
+	{
 		ret = erofs_fscache_register_cookie(sb, &dif->fscache,
-				dif->path, false);
+											dif->path, false);
 		if (ret)
 			return ret;
-	} else {
+	}
+	else if (sbi->blob_dir_path)
+	{
+		struct file *f;
+
+		f = file_open_root(sbi->blob_dir.dentry, sbi->blob_dir.mnt,
+						   dif->path, O_RDONLY | O_LARGEFILE, 0);
+		if (IS_ERR(f))
+		{
+			erofs_err(sb, "failed to open blob id %s", dif->path);
+			return PTR_ERR(f);
+		}
+		dif->blobfile = f;
+	}
+	else if (!sbi->devs->flatdev)
+	{
 		bdev = blkdev_get_by_path(dif->path, FMODE_READ | FMODE_EXCL,
-					  sb->s_type);
+								  sb->s_type);
 		if (IS_ERR(bdev))
 			return PTR_ERR(bdev);
 		dif->bdev = bdev;
@@ -266,7 +294,7 @@ static int erofs_init_device(struct erofs_buf *buf, struct super_block *sb,
 }
 
 static int erofs_scan_devices(struct super_block *sb,
-			      struct erofs_super_block *dsb)
+							  struct erofs_super_block *dsb)
 {
 	struct erofs_sb_info *sbi = EROFS_SB(sb);
 	unsigned int ondisk_extradevs;
@@ -282,9 +310,10 @@ static int erofs_scan_devices(struct super_block *sb,
 		ondisk_extradevs = le16_to_cpu(dsb->extra_devices);
 
 	if (sbi->devs->extra_devices &&
-	    ondisk_extradevs != sbi->devs->extra_devices) {
+		ondisk_extradevs != sbi->devs->extra_devices)
+	{
 		erofs_err(sb, "extra devices don't match (ondisk %u, given %u)",
-			  ondisk_extradevs, sbi->devs->extra_devices);
+				  ondisk_extradevs, sbi->devs->extra_devices);
 		return -EINVAL;
 	}
 	if (!ondisk_extradevs)
@@ -293,22 +322,29 @@ static int erofs_scan_devices(struct super_block *sb,
 	sbi->device_id_mask = roundup_pow_of_two(ondisk_extradevs + 1) - 1;
 	pos = le16_to_cpu(dsb->devt_slotoff) * EROFS_DEVT_SLOT_SIZE;
 	down_read(&sbi->devs->rwsem);
-	if (sbi->devs->extra_devices) {
-		idr_for_each_entry(&sbi->devs->tree, dif, id) {
+	if (sbi->devs->extra_devices)
+	{
+		idr_for_each_entry(&sbi->devs->tree, dif, id)
+		{
 			err = erofs_init_device(&buf, sb, dif, &pos);
 			if (err)
 				break;
 		}
-	} else {
-		for (id = 0; id < ondisk_extradevs; id++) {
+	}
+	else
+	{
+		for (id = 0; id < ondisk_extradevs; id++)
+		{
 			dif = kzalloc(sizeof(*dif), GFP_KERNEL);
-			if (!dif) {
+			if (!dif)
+			{
 				err = -ENOMEM;
 				break;
 			}
 
 			err = idr_alloc(&sbi->devs->tree, dif, 0, 0, GFP_KERNEL);
-			if (err < 0) {
+			if (err < 0)
+			{
 				kfree(dif);
 				break;
 			}
@@ -334,7 +370,8 @@ static int erofs_read_superblock(struct super_block *sb)
 	int ret;
 
 	data = erofs_read_metabuf(&buf, sb, 0, EROFS_KMAP);
-	if (IS_ERR(data)) {
+	if (IS_ERR(data))
+	{
 		erofs_err(sb, "cannot read erofs superblock");
 		return PTR_ERR(data);
 	}
@@ -343,13 +380,15 @@ static int erofs_read_superblock(struct super_block *sb)
 	dsb = (struct erofs_super_block *)(data + EROFS_SUPER_OFFSET);
 
 	ret = -EINVAL;
-	if (le32_to_cpu(dsb->magic) != EROFS_SUPER_MAGIC_V1) {
+	if (le32_to_cpu(dsb->magic) != EROFS_SUPER_MAGIC_V1)
+	{
 		erofs_err(sb, "cannot find valid erofs superblock");
 		goto out;
 	}
 
 	sbi->feature_compat = le32_to_cpu(dsb->feature_compat);
-	if (erofs_sb_has_sb_chksum(sbi)) {
+	if (erofs_sb_has_sb_chksum(sbi))
+	{
 		ret = erofs_superblock_csum_verify(sb, data);
 		if (ret)
 			goto out;
@@ -358,9 +397,10 @@ static int erofs_read_superblock(struct super_block *sb)
 	ret = -EINVAL;
 	blkszbits = dsb->blkszbits;
 	/* 9(512 bytes) + LOG_SECTORS_PER_BLOCK == LOG_BLOCK_SIZE */
-	if (blkszbits != LOG_BLOCK_SIZE) {
+	if (blkszbits != LOG_BLOCK_SIZE)
+	{
 		erofs_err(sb, "blkszbits %u isn't supported on this platform",
-			  blkszbits);
+				  blkszbits);
 		goto out;
 	}
 
@@ -368,9 +408,10 @@ static int erofs_read_superblock(struct super_block *sb)
 		goto out;
 
 	sbi->sb_size = 128 + dsb->sb_extslots * EROFS_SB_EXTSLOT_SIZE;
-	if (sbi->sb_size > EROFS_BLKSIZ) {
+	if (sbi->sb_size > EROFS_BLKSIZ)
+	{
 		erofs_err(sb, "invalid sb_extslots %u (more than a fs block)",
-			  sbi->sb_size);
+				  sbi->sb_size);
 		goto out;
 	}
 	sbi->primarydevice_blocks = le32_to_cpu(dsb->blocks);
@@ -388,8 +429,9 @@ static int erofs_read_superblock(struct super_block *sb)
 	memcpy(&sb->s_uuid, dsb->uuid, sizeof(dsb->uuid));
 
 	ret = strscpy(sbi->volume_name, dsb->volume_name,
-		      sizeof(dsb->volume_name));
-	if (ret < 0) {	/* -E2BIG */
+				  sizeof(dsb->volume_name));
+	if (ret < 0)
+	{ /* -E2BIG */
 		erofs_err(sb, "bad volume name without NIL terminator");
 		ret = -EFSCORRUPTED;
 		goto out;
@@ -431,7 +473,8 @@ static void erofs_default_options(struct erofs_fs_context *ctx)
 #endif
 }
 
-enum {
+enum
+{
 	Opt_user_xattr,
 	Opt_acl,
 	Opt_cache_strategy,
@@ -440,41 +483,41 @@ enum {
 	Opt_device,
 	Opt_fsid,
 	Opt_bootstrap_path,
+	Opt_blob_dir_path,
 	Opt_err
 };
 
 static const struct constant_table erofs_param_cache_strategy[] = {
-	{"disabled",	EROFS_ZIP_CACHE_DISABLED},
-	{"readahead",	EROFS_ZIP_CACHE_READAHEAD},
-	{"readaround",	EROFS_ZIP_CACHE_READAROUND},
-	{}
-};
+	{"disabled", EROFS_ZIP_CACHE_DISABLED},
+	{"readahead", EROFS_ZIP_CACHE_READAHEAD},
+	{"readaround", EROFS_ZIP_CACHE_READAROUND},
+	{}};
 
 static const struct constant_table erofs_dax_param_enums[] = {
-	{"always",	EROFS_MOUNT_DAX_ALWAYS},
-	{"never",	EROFS_MOUNT_DAX_NEVER},
-	{}
-};
+	{"always", EROFS_MOUNT_DAX_ALWAYS},
+	{"never", EROFS_MOUNT_DAX_NEVER},
+	{}};
 
 static const struct fs_parameter_spec erofs_fs_parameters[] = {
-	fsparam_flag_no("user_xattr",	Opt_user_xattr),
-	fsparam_flag_no("acl",		Opt_acl),
-	fsparam_enum("cache_strategy",	Opt_cache_strategy,
-		     erofs_param_cache_strategy),
-	fsparam_flag("dax",             Opt_dax),
-	fsparam_enum("dax",		Opt_dax_enum, erofs_dax_param_enums),
-	fsparam_string("device",	Opt_device),
-	fsparam_string("fsid",		Opt_fsid),
-	fsparam_string("bootstrap_path",	Opt_bootstrap_path),
-	{}
-};
+	fsparam_flag_no("user_xattr", Opt_user_xattr),
+	fsparam_flag_no("acl", Opt_acl),
+	fsparam_enum("cache_strategy", Opt_cache_strategy,
+				 erofs_param_cache_strategy),
+	fsparam_flag("dax", Opt_dax),
+	fsparam_enum("dax", Opt_dax_enum, erofs_dax_param_enums),
+	fsparam_string("device", Opt_device),
+	fsparam_string("fsid", Opt_fsid),
+	fsparam_string("bootstrap_path", Opt_bootstrap_path),
+	fsparam_string("blob_dir_path", Opt_blob_dir_path),
+	{}};
 
 static bool erofs_fc_set_dax_mode(struct fs_context *fc, unsigned int mode)
 {
 #ifdef CONFIG_FS_DAX
 	struct erofs_fs_context *ctx = fc->fs_private;
 
-	switch (mode) {
+	switch (mode)
+	{
 	case EROFS_MOUNT_DAX_ALWAYS:
 		warnfc(fc, "DAX enabled. Warning: EXPERIMENTAL, use at your own risk");
 		set_opt(&ctx->opt, DAX_ALWAYS);
@@ -495,7 +538,7 @@ static bool erofs_fc_set_dax_mode(struct fs_context *fc, unsigned int mode)
 }
 
 static int erofs_fc_parse_param(struct fs_context *fc,
-				struct fs_parameter *param)
+								struct fs_parameter *param)
 {
 	struct erofs_fs_context *ctx = fc->fs_private;
 	struct fs_parse_result result;
@@ -506,7 +549,8 @@ static int erofs_fc_parse_param(struct fs_context *fc,
 	if (opt < 0)
 		return opt;
 
-	switch (opt) {
+	switch (opt)
+	{
 	case Opt_user_xattr:
 #ifdef CONFIG_EROFS_FS_XATTR
 		if (result.boolean)
@@ -547,14 +591,16 @@ static int erofs_fc_parse_param(struct fs_context *fc,
 		if (!dif)
 			return -ENOMEM;
 		dif->path = kstrdup(param->string, GFP_KERNEL);
-		if (!dif->path) {
+		if (!dif->path)
+		{
 			kfree(dif);
 			return -ENOMEM;
 		}
 		down_write(&ctx->devs->rwsem);
 		ret = idr_alloc(&ctx->devs->tree, dif, 0, 0, GFP_KERNEL);
 		up_write(&ctx->devs->rwsem);
-		if (ret < 0) {
+		if (ret < 0)
+		{
 			kfree(dif->path);
 			kfree(dif);
 			return ret;
@@ -568,6 +614,13 @@ static int erofs_fc_parse_param(struct fs_context *fc,
 			return -ENOMEM;
 		infofc(fc, "RAFS bootstrap_path %s", ctx->bootstrap_path);
 		break;
+	case Opt_blob_dir_path:
+		kfree(ctx->blob_dir_path);
+		ctx->blob_dir_path = kstrdup(param->string, GFP_KERNEL);
+		if (!ctx->blob_dir_path)
+			return -ENOMEM;
+		infofc(fc, "RAFS blob_dir_path %s", ctx->blob_dir_path);
+		break;
 	case Opt_fsid:
 #ifdef CONFIG_EROFS_FS_ONDEMAND
 		kfree(ctx->opt.fsid);
@@ -607,7 +660,7 @@ static bool erofs_managed_cache_release_folio(struct folio *folio, gfp_t gfp)
  * We could introduce an extra locking instead but it seems unnecessary.
  */
 static void erofs_managed_cache_invalidate_folio(struct folio *folio,
-					       size_t offset, size_t length)
+												 size_t offset, size_t length)
 {
 	const size_t stop = length + offset;
 
@@ -643,27 +696,30 @@ static int erofs_init_managed_cache(struct super_block *sb)
 	return 0;
 }
 #else
-static int erofs_init_managed_cache(struct super_block *sb) { return 0; }
+static int erofs_init_managed_cache(struct super_block *sb)
+{
+	return 0;
+}
 #endif
 
 static struct inode *erofs_nfs_get_inode(struct super_block *sb,
-					 u64 ino, u32 generation)
+										 u64 ino, u32 generation)
 {
 	return erofs_iget(sb, ino, false);
 }
 
 static struct dentry *erofs_fh_to_dentry(struct super_block *sb,
-		struct fid *fid, int fh_len, int fh_type)
+										 struct fid *fid, int fh_len, int fh_type)
 {
 	return generic_fh_to_dentry(sb, fid, fh_len, fh_type,
-				    erofs_nfs_get_inode);
+								erofs_nfs_get_inode);
 }
 
 static struct dentry *erofs_fh_to_parent(struct super_block *sb,
-		struct fid *fid, int fh_len, int fh_type)
+										 struct fid *fid, int fh_len, int fh_type)
 {
 	return generic_fh_to_parent(sb, fid, fh_len, fh_type,
-				    erofs_nfs_get_inode);
+								erofs_nfs_get_inode);
 }
 
 static struct dentry *erofs_get_parent(struct dentry *child)
@@ -688,7 +744,8 @@ static int rafs_v6_fill_super(struct super_block *sb)
 {
 	struct erofs_sb_info *sbi = EROFS_SB(sb);
 
-	if (sbi->bootstrap_path) {
+	if (sbi->bootstrap_path)
+	{
 		struct file *f;
 
 		f = filp_open(sbi->bootstrap_path, O_RDONLY, 0644);
@@ -696,7 +753,19 @@ static int rafs_v6_fill_super(struct super_block *sb)
 			return PTR_ERR(f);
 		sbi->bootstrap = f;
 	}
-	/* TODO: open each blobfiles */
+	if (sbi->blob_dir_path)
+	{
+		int ret = kern_path(sbi->blob_dir_path,
+							LOOKUP_FOLLOW | LOOKUP_DIRECTORY,
+							&sbi->blob_dir);
+
+		if (ret)
+		{
+			kfree(sbi->blob_dir_path);
+			sbi->blob_dir_path = NULL;
+			return ret;
+		}
+	}
 	return 0;
 }
 
@@ -723,8 +792,11 @@ static int erofs_fc_fill_super(struct super_block *sb, struct fs_context *fc)
 	ctx->devs = NULL;
 	sbi->bootstrap_path = ctx->bootstrap_path;
 	ctx->bootstrap_path = NULL;
+	sbi->blob_dir_path = ctx->blob_dir_path;
+	ctx->blob_dir_path = NULL;
 
-	if (erofs_is_fscache_mode(sb)) {
+	if (erofs_is_fscache_mode(sb))
+	{
 		sb->s_blocksize = EROFS_BLKSIZ;
 		sb->s_blocksize_bits = LOG_BLOCK_SIZE;
 
@@ -733,383 +805,408 @@ static int erofs_fc_fill_super(struct super_block *sb, struct fs_context *fc)
 			return err;
 
 		err = erofs_fscache_register_cookie(sb, &sbi->s_fscache,
-						    sbi->opt.fsid, true);
+											sbi->opt.fsid, true);
 		if (err)
 			return err;
 
 		err = super_setup_bdi(sb);
 		if (err)
 			return err;
-	} else {
-		if (!sb_set_blocksize(sb, EROFS_BLKSIZ)) {
+	}
+	else
+	{
+		if (!sb_set_blocksize(sb, EROFS_BLKSIZ))
+		{
 			erofs_err(sb, "failed to set erofs blksize");
 			return -EINVAL;
 		}
 
 		sbi->dax_dev = fs_dax_get_by_bdev(sb->s_bdev,
-						  &sbi->dax_part_off);
+										  &sbi->dax_part_off);
 	}
 
 	err = erofs_read_superblock(sb);
 	if (err)
 		return err;
 
-	if (sb->s_blocksize_bits != sbi->blkszbits) {
-		if (erofs_is_fscache_mode(sb)) {
+	if (sb->s_blocksize_bits != sbi->blkszbits)
+	{
+		if (erofs_is_fscache_mode(sb))
+		{
 			errorfc(fc, "unsupported blksize for fscache mode");
 			return -EINVAL;
 		}
-		if (!sb_set_blocksize(sb, 1 << sbi->blkszbits)) {
-		if (sb->s_bdev && !sb_set_blocksize(sb, 1 << sbi->blkszbits)) {
-			errorfc(fc, "failed to set erofs blksize");
-			return -EINVAL;
-		} else {
-			sb->s_blocksize =  1 << sbi->blkszbits;
-			sb->s_blocksize_bits = sbi->blkszbits;
+		if (!sb_set_blocksize(sb, 1 << sbi->blkszbits))
+		{
+			if (sb->s_bdev && !sb_set_blocksize(sb, 1 << sbi->blkszbits))
+			{
+				errorfc(fc, "failed to set erofs blksize");
+				return -EINVAL;
+			}
+			else
+			{
+				sb->s_blocksize = 1 << sbi->blkszbits;
+				sb->s_blocksize_bits = sbi->blkszbits;
+			}
 		}
-	}
 
-	err = rafs_v6_fill_super(sb);
-	if (err)
-		return err;
+		err = rafs_v6_fill_super(sb);
+		if (err)
+			return err;
 
-	if (test_opt(&sbi->opt, DAX_ALWAYS)) {
-		BUILD_BUG_ON(EROFS_BLKSIZ != PAGE_SIZE);
+		if (test_opt(&sbi->opt, DAX_ALWAYS))
+		{
+			BUILD_BUG_ON(EROFS_BLKSIZ != PAGE_SIZE);
 
-		if (!sbi->dax_dev) {
-			errorfc(fc, "DAX unsupported by block device. Turning off DAX.");
-			clear_opt(&sbi->opt, DAX_ALWAYS);
+			if (!sbi->dax_dev)
+			{
+				errorfc(fc, "DAX unsupported by block device. Turning off DAX.");
+				clear_opt(&sbi->opt, DAX_ALWAYS);
+			}
 		}
-	}
 
-	sb->s_time_gran = 1;
-	sb->s_xattr = erofs_xattr_handlers;
-	sb->s_export_op = &erofs_export_ops;
+		sb->s_time_gran = 1;
+		sb->s_xattr = erofs_xattr_handlers;
+		sb->s_export_op = &erofs_export_ops;
 
-	if (test_opt(&sbi->opt, POSIX_ACL))
-		sb->s_flags |= SB_POSIXACL;
-	else
-		sb->s_flags &= ~SB_POSIXACL;
+		if (test_opt(&sbi->opt, POSIX_ACL))
+			sb->s_flags |= SB_POSIXACL;
+		else
+			sb->s_flags &= ~SB_POSIXACL;
 
 #ifdef CONFIG_EROFS_FS_ZIP
-	xa_init(&sbi->managed_pslots);
+		xa_init(&sbi->managed_pslots);
 #endif
 
-	/* get the root inode */
-	inode = erofs_iget(sb, ROOT_NID(sbi), true);
-	if (IS_ERR(inode))
-		return PTR_ERR(inode);
-
-	if (!S_ISDIR(inode->i_mode)) {
-		erofs_err(sb, "rootino(nid %llu) is not a directory(i_mode %o)",
-			  ROOT_NID(sbi), inode->i_mode);
-		iput(inode);
-		return -EINVAL;
-	}
-
-	sb->s_root = d_make_root(inode);
-	if (!sb->s_root)
-		return -ENOMEM;
-
-	erofs_shrinker_register(sb);
-	/* sb->s_umount is already locked, SB_ACTIVE and SB_BORN are not set */
-	err = erofs_init_managed_cache(sb);
-	if (err)
-		return err;
+		/* get the root inode */
+		inode = erofs_iget(sb, ROOT_NID(sbi), true);
+		if (IS_ERR(inode))
+			return PTR_ERR(inode);
 
-	err = erofs_register_sysfs(sb);
-	if (err)
-		return err;
+		if (!S_ISDIR(inode->i_mode))
+		{
+			erofs_err(sb, "rootino(nid %llu) is not a directory(i_mode %o)",
+					  ROOT_NID(sbi), inode->i_mode);
+			iput(inode);
+			return -EINVAL;
+		}
 
-	erofs_info(sb, "mounted with root inode @ nid %llu.", ROOT_NID(sbi));
-	return 0;
-}
+		sb->s_root = d_make_root(inode);
+		if (!sb->s_root)
+			return -ENOMEM;
 
-static int erofs_fc_get_tree(struct fs_context *fc)
-{
-	struct erofs_fs_context *ctx = fc->fs_private;
+		erofs_shrinker_register(sb);
+		/* sb->s_umount is already locked, SB_ACTIVE and SB_BORN are not set */
+		err = erofs_init_managed_cache(sb);
+		if (err)
+			return err;
 
-	if (IS_ENABLED(CONFIG_EROFS_FS_ONDEMAND) && ctx->opt.fsid)
-		return get_tree_nodev(fc, erofs_fc_fill_super);
+		err = erofs_register_sysfs(sb);
+		if (err)
+			return err;
 
-	if (ctx->bootstrap_path)
-		return get_tree_nodev(fc, erofs_fc_fill_super);
+		erofs_info(sb, "mounted with root inode @ nid %llu.", ROOT_NID(sbi));
+		return 0;
+	}
 
-	return get_tree_bdev(fc, erofs_fc_fill_super);
-}
+	static int erofs_fc_get_tree(struct fs_context * fc)
+	{
+		struct erofs_fs_context *ctx = fc->fs_private;
 
-static int erofs_fc_reconfigure(struct fs_context *fc)
-{
-	struct super_block *sb = fc->root->d_sb;
-	struct erofs_sb_info *sbi = EROFS_SB(sb);
-	struct erofs_fs_context *ctx = fc->fs_private;
+		if (IS_ENABLED(CONFIG_EROFS_FS_ONDEMAND) && ctx->opt.fsid)
+			return get_tree_nodev(fc, erofs_fc_fill_super);
 
-	DBG_BUGON(!sb_rdonly(sb));
+		if (ctx->bootstrap_path && ctx->blob_dir_path)
+			return get_tree_nodev(fc, erofs_fc_fill_super);
 
-	if (test_opt(&ctx->opt, POSIX_ACL))
-		fc->sb_flags |= SB_POSIXACL;
-	else
-		fc->sb_flags &= ~SB_POSIXACL;
+		return get_tree_bdev(fc, erofs_fc_fill_super);
+	}
 
-	sbi->opt = ctx->opt;
+	static int erofs_fc_reconfigure(struct fs_context * fc)
+	{
+		struct super_block *sb = fc->root->d_sb;
+		struct erofs_sb_info *sbi = EROFS_SB(sb);
+		struct erofs_fs_context *ctx = fc->fs_private;
 
-	fc->sb_flags |= SB_RDONLY;
-	return 0;
-}
+		DBG_BUGON(!sb_rdonly(sb));
 
-static int erofs_release_device_info(int id, void *ptr, void *data)
-{
-	struct erofs_device_info *dif = ptr;
-
-	fs_put_dax(dif->dax_dev);
-	if (dif->bdev)
-		blkdev_put(dif->bdev, FMODE_READ | FMODE_EXCL);
-	erofs_fscache_unregister_cookie(&dif->fscache);
-	kfree(dif->path);
-	kfree(dif);
-	return 0;
-}
+		if (test_opt(&ctx->opt, POSIX_ACL))
+			fc->sb_flags |= SB_POSIXACL;
+		else
+			fc->sb_flags &= ~SB_POSIXACL;
 
-static void erofs_free_dev_context(struct erofs_dev_context *devs)
-{
-	if (!devs)
-		return;
-	idr_for_each(&devs->tree, &erofs_release_device_info, NULL);
-	idr_destroy(&devs->tree);
-	kfree(devs);
-}
+		sbi->opt = ctx->opt;
 
-static void erofs_fc_free(struct fs_context *fc)
-{
-	struct erofs_fs_context *ctx = fc->fs_private;
+		fc->sb_flags |= SB_RDONLY;
+		return 0;
+	}
 
-	erofs_free_dev_context(ctx->devs);
-	kfree(ctx->opt.fsid);
-	kfree(ctx);
-}
+	static int erofs_release_device_info(int id, void *ptr, void *data)
+	{
+		struct erofs_device_info *dif = ptr;
+
+		fs_put_dax(dif->dax_dev);
+		if (dif->bdev)
+			blkdev_put(dif->bdev, FMODE_READ | FMODE_EXCL);
+		if (dif->blobfile)
+			filp_close(dif->blobfile, NULL);
+		erofs_fscache_unregister_cookie(&dif->fscache);
+		kfree(dif->path);
+		kfree(dif);
+		return 0;
+	}
 
-static const struct fs_context_operations erofs_context_ops = {
-	.parse_param	= erofs_fc_parse_param,
-	.get_tree       = erofs_fc_get_tree,
-	.reconfigure    = erofs_fc_reconfigure,
-	.free		= erofs_fc_free,
-};
+	static void erofs_free_dev_context(struct erofs_dev_context * devs)
+	{
+		if (!devs)
+			return;
+		idr_for_each(&devs->tree, &erofs_release_device_info, NULL);
+		idr_destroy(&devs->tree);
+		kfree(devs);
+	}
 
-static int erofs_init_fs_context(struct fs_context *fc)
-{
-	struct erofs_fs_context *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
+	static void erofs_fc_free(struct fs_context * fc)
+	{
+		struct erofs_fs_context *ctx = fc->fs_private;
 
-	if (!ctx)
-		return -ENOMEM;
-	ctx->devs = kzalloc(sizeof(struct erofs_dev_context), GFP_KERNEL);
-	if (!ctx->devs) {
+		erofs_free_dev_context(ctx->devs);
+		kfree(ctx->opt.fsid);
 		kfree(ctx);
-		return -ENOMEM;
 	}
-	fc->fs_private = ctx;
-
-	idr_init(&ctx->devs->tree);
-	init_rwsem(&ctx->devs->rwsem);
-	erofs_default_options(ctx);
-	fc->ops = &erofs_context_ops;
-	return 0;
-}
 
-/*
- * could be triggered after deactivate_locked_super()
- * is called, thus including umount and failed to initialize.
- */
-static void erofs_kill_sb(struct super_block *sb)
-{
-	struct erofs_sb_info *sbi;
+	static const struct fs_context_operations erofs_context_ops = {
+		.parse_param = erofs_fc_parse_param,
+		.get_tree = erofs_fc_get_tree,
+		.reconfigure = erofs_fc_reconfigure,
+		.free = erofs_fc_free,
+	};
 
-	WARN_ON(sb->s_magic != EROFS_SUPER_MAGIC);
+	static int erofs_init_fs_context(struct fs_context * fc)
+	{
+		struct erofs_fs_context *ctx = kzalloc(sizeof(*ctx), GFP_KERNEL);
 
-	if (sb->s_bdev)
-		kill_block_super(sb);
-	else
-		kill_anon_super(sb);
+		if (!ctx)
+			return -ENOMEM;
+		ctx->devs = kzalloc(sizeof(struct erofs_dev_context), GFP_KERNEL);
+		if (!ctx->devs)
+		{
+			kfree(ctx);
+			return -ENOMEM;
+		}
+		fc->fs_private = ctx;
 
-	sbi = EROFS_SB(sb);
-	if (!sbi)
-		return;
-
-	erofs_free_dev_context(sbi->devs);
-	fs_put_dax(sbi->dax_dev);
-	erofs_fscache_unregister_cookie(&sbi->s_fscache);
-	erofs_fscache_unregister_fs(sb);
-	kfree(sbi->opt.fsid);
-	kfree(sbi);
-	sb->s_fs_info = NULL;
-}
+		idr_init(&ctx->devs->tree);
+		init_rwsem(&ctx->devs->rwsem);
+		erofs_default_options(ctx);
+		fc->ops = &erofs_context_ops;
+		return 0;
+	}
 
-/* called when ->s_root is non-NULL */
-static void erofs_put_super(struct super_block *sb)
-{
-	struct erofs_sb_info *const sbi = EROFS_SB(sb);
+	/*
+	 * could be triggered after deactivate_locked_super()
+	 * is called, thus including umount and failed to initialize.
+	 */
+	static void erofs_kill_sb(struct super_block * sb)
+	{
+		struct erofs_sb_info *sbi;
 
-	DBG_BUGON(!sbi);
-	
-	if (sbi->bootstrap)
-		filp_close(sbi->bootstrap, NULL);
-	kfree(sbi->bootstrap_path);
+		WARN_ON(sb->s_magic != EROFS_SUPER_MAGIC);
 
-	erofs_unregister_sysfs(sb);
-	erofs_shrinker_unregister(sb);
-#ifdef CONFIG_EROFS_FS_ZIP
-	iput(sbi->managed_cache);
-	sbi->managed_cache = NULL;
-#endif
-	erofs_fscache_unregister_cookie(&sbi->s_fscache);
-}
+		if (sb->s_bdev)
+			kill_block_super(sb);
+		else
+			kill_anon_super(sb);
+
+		sbi = EROFS_SB(sb);
+		if (!sbi)
+			return;
+
+		erofs_free_dev_context(sbi->devs);
+		if (sbi->bootstrap)
+			filp_close(sbi->bootstrap, NULL);
+		if (sbi->blob_dir_path)
+		{
+			path_put(&sbi->blob_dir);
+			kfree(sbi->blob_dir_path);
+		}
+		kfree(sbi->bootstrap_path);
+		fs_put_dax(sbi->dax_dev);
+		erofs_fscache_unregister_cookie(&sbi->s_fscache);
+		erofs_fscache_unregister_fs(sb);
+		kfree(sbi->opt.fsid);
+		kfree(sbi);
+		sb->s_fs_info = NULL;
+	}
 
-static struct file_system_type erofs_fs_type = {
-	.owner          = THIS_MODULE,
-	.name           = "erofs",
-	.init_fs_context = erofs_init_fs_context,
-	.kill_sb        = erofs_kill_sb,
-	.fs_flags       = FS_REQUIRES_DEV | FS_ALLOW_IDMAP,
-};
-MODULE_ALIAS_FS("erofs");
+	/* called when ->s_root is non-NULL */
+	static void erofs_put_super(struct super_block * sb)
+	{
+		struct erofs_sb_info *const sbi = EROFS_SB(sb);
 
-static int __init erofs_module_init(void)
-{
-	int err;
+		DBG_BUGON(!sbi);
 
-	erofs_check_ondisk_layout_definitions();
+		if (sbi->bootstrap)
+			filp_close(sbi->bootstrap, NULL);
+		kfree(sbi->bootstrap_path);
 
-	erofs_inode_cachep = kmem_cache_create("erofs_inode",
-					       sizeof(struct erofs_inode), 0,
-					       SLAB_RECLAIM_ACCOUNT,
-					       erofs_inode_init_once);
-	if (!erofs_inode_cachep) {
-		err = -ENOMEM;
-		goto icache_err;
+		erofs_unregister_sysfs(sb);
+		erofs_shrinker_unregister(sb);
+#ifdef CONFIG_EROFS_FS_ZIP
+		iput(sbi->managed_cache);
+		sbi->managed_cache = NULL;
+#endif
+		erofs_fscache_unregister_cookie(&sbi->s_fscache);
 	}
 
-	err = erofs_init_shrinker();
-	if (err)
-		goto shrinker_err;
+	static struct file_system_type erofs_fs_type = {
+		.owner = THIS_MODULE,
+		.name = "erofs",
+		.init_fs_context = erofs_init_fs_context,
+		.kill_sb = erofs_kill_sb,
+		.fs_flags = FS_REQUIRES_DEV | FS_ALLOW_IDMAP,
+	};
+	MODULE_ALIAS_FS("erofs");
+
+	static int __init erofs_module_init(void)
+	{
+		int err;
+
+		erofs_check_ondisk_layout_definitions();
+
+		erofs_inode_cachep = kmem_cache_create("erofs_inode",
+											   sizeof(struct erofs_inode), 0,
+											   SLAB_RECLAIM_ACCOUNT,
+											   erofs_inode_init_once);
+		if (!erofs_inode_cachep)
+		{
+			err = -ENOMEM;
+			goto icache_err;
+		}
 
-	err = z_erofs_lzma_init();
-	if (err)
-		goto lzma_err;
+		err = erofs_init_shrinker();
+		if (err)
+			goto shrinker_err;
 
-	erofs_pcpubuf_init();
-	err = z_erofs_init_zip_subsystem();
-	if (err)
-		goto zip_err;
+		err = z_erofs_lzma_init();
+		if (err)
+			goto lzma_err;
 
-	err = erofs_init_sysfs();
-	if (err)
-		goto sysfs_err;
+		erofs_pcpubuf_init();
+		err = z_erofs_init_zip_subsystem();
+		if (err)
+			goto zip_err;
 
-	err = register_filesystem(&erofs_fs_type);
-	if (err)
-		goto fs_err;
+		err = erofs_init_sysfs();
+		if (err)
+			goto sysfs_err;
 
-	return 0;
+		err = register_filesystem(&erofs_fs_type);
+		if (err)
+			goto fs_err;
 
-fs_err:
-	erofs_exit_sysfs();
-sysfs_err:
-	z_erofs_exit_zip_subsystem();
-zip_err:
-	z_erofs_lzma_exit();
-lzma_err:
-	erofs_exit_shrinker();
-shrinker_err:
-	kmem_cache_destroy(erofs_inode_cachep);
-icache_err:
-	return err;
-}
+		return 0;
 
-static void __exit erofs_module_exit(void)
-{
-	unregister_filesystem(&erofs_fs_type);
+	fs_err:
+		erofs_exit_sysfs();
+	sysfs_err:
+		z_erofs_exit_zip_subsystem();
+	zip_err:
+		z_erofs_lzma_exit();
+	lzma_err:
+		erofs_exit_shrinker();
+	shrinker_err:
+		kmem_cache_destroy(erofs_inode_cachep);
+	icache_err:
+		return err;
+	}
 
-	/* Ensure all RCU free inodes / pclusters are safe to be destroyed. */
-	rcu_barrier();
+	static void __exit erofs_module_exit(void)
+	{
+		unregister_filesystem(&erofs_fs_type);
 
-	erofs_exit_sysfs();
-	z_erofs_exit_zip_subsystem();
-	z_erofs_lzma_exit();
-	erofs_exit_shrinker();
-	kmem_cache_destroy(erofs_inode_cachep);
-	erofs_pcpubuf_exit();
-}
+		/* Ensure all RCU free inodes / pclusters are safe to be destroyed. */
+		rcu_barrier();
 
-/* get filesystem statistics */
-static int erofs_statfs(struct dentry *dentry, struct kstatfs *buf)
-{
-	struct super_block *sb = dentry->d_sb;
-	struct erofs_sb_info *sbi = EROFS_SB(sb);
-	u64 id = 0;
+		erofs_exit_sysfs();
+		z_erofs_exit_zip_subsystem();
+		z_erofs_lzma_exit();
+		erofs_exit_shrinker();
+		kmem_cache_destroy(erofs_inode_cachep);
+		erofs_pcpubuf_exit();
+	}
 
-	if (sb->s_bdev)
-		id = huge_encode_dev(sb->s_bdev->bd_dev);
+	/* get filesystem statistics */
+	static int erofs_statfs(struct dentry * dentry, struct kstatfs * buf)
+	{
+		struct super_block *sb = dentry->d_sb;
+		struct erofs_sb_info *sbi = EROFS_SB(sb);
+		u64 id = 0;
 
-	buf->f_type = sb->s_magic;
-	buf->f_bsize = EROFS_BLKSIZ;
-	buf->f_blocks = sbi->total_blocks;
-	buf->f_bfree = buf->f_bavail = 0;
+		if (sb->s_bdev)
+			id = huge_encode_dev(sb->s_bdev->bd_dev);
 
-	buf->f_files = ULLONG_MAX;
-	buf->f_ffree = ULLONG_MAX - sbi->inos;
+		buf->f_type = sb->s_magic;
+		buf->f_bsize = EROFS_BLKSIZ;
+		buf->f_blocks = sbi->total_blocks;
+		buf->f_bfree = buf->f_bavail = 0;
 
-	buf->f_namelen = EROFS_NAME_LEN;
+		buf->f_files = ULLONG_MAX;
+		buf->f_ffree = ULLONG_MAX - sbi->inos;
 
-	buf->f_fsid    = u64_to_fsid(id);
-	return 0;
-}
+		buf->f_namelen = EROFS_NAME_LEN;
 
-static int erofs_show_options(struct seq_file *seq, struct dentry *root)
-{
-	struct erofs_sb_info *sbi = EROFS_SB(root->d_sb);
-	struct erofs_mount_opts *opt = &sbi->opt;
+		buf->f_fsid = u64_to_fsid(id);
+		return 0;
+	}
+
+	static int erofs_show_options(struct seq_file * seq, struct dentry * root)
+	{
+		struct erofs_sb_info *sbi = EROFS_SB(root->d_sb);
+		struct erofs_mount_opts *opt = &sbi->opt;
 
 #ifdef CONFIG_EROFS_FS_XATTR
-	if (test_opt(opt, XATTR_USER))
-		seq_puts(seq, ",user_xattr");
-	else
-		seq_puts(seq, ",nouser_xattr");
+		if (test_opt(opt, XATTR_USER))
+			seq_puts(seq, ",user_xattr");
+		else
+			seq_puts(seq, ",nouser_xattr");
 #endif
 #ifdef CONFIG_EROFS_FS_POSIX_ACL
-	if (test_opt(opt, POSIX_ACL))
-		seq_puts(seq, ",acl");
-	else
-		seq_puts(seq, ",noacl");
+		if (test_opt(opt, POSIX_ACL))
+			seq_puts(seq, ",acl");
+		else
+			seq_puts(seq, ",noacl");
 #endif
 #ifdef CONFIG_EROFS_FS_ZIP
-	if (opt->cache_strategy == EROFS_ZIP_CACHE_DISABLED)
-		seq_puts(seq, ",cache_strategy=disabled");
-	else if (opt->cache_strategy == EROFS_ZIP_CACHE_READAHEAD)
-		seq_puts(seq, ",cache_strategy=readahead");
-	else if (opt->cache_strategy == EROFS_ZIP_CACHE_READAROUND)
-		seq_puts(seq, ",cache_strategy=readaround");
+		if (opt->cache_strategy == EROFS_ZIP_CACHE_DISABLED)
+			seq_puts(seq, ",cache_strategy=disabled");
+		else if (opt->cache_strategy == EROFS_ZIP_CACHE_READAHEAD)
+			seq_puts(seq, ",cache_strategy=readahead");
+		else if (opt->cache_strategy == EROFS_ZIP_CACHE_READAROUND)
+			seq_puts(seq, ",cache_strategy=readaround");
 #endif
-	if (test_opt(opt, DAX_ALWAYS))
-		seq_puts(seq, ",dax=always");
-	if (test_opt(opt, DAX_NEVER))
-		seq_puts(seq, ",dax=never");
+		if (test_opt(opt, DAX_ALWAYS))
+			seq_puts(seq, ",dax=always");
+		if (test_opt(opt, DAX_NEVER))
+			seq_puts(seq, ",dax=never");
 #ifdef CONFIG_EROFS_FS_ONDEMAND
-	if (opt->fsid)
-		seq_printf(seq, ",fsid=%s", opt->fsid);
+		if (opt->fsid)
+			seq_printf(seq, ",fsid=%s", opt->fsid);
 #endif
-	return 0;
-}
+		return 0;
+	}
 
-const struct super_operations erofs_sops = {
-	.put_super = erofs_put_super,
-	.alloc_inode = erofs_alloc_inode,
-	.free_inode = erofs_free_inode,
-	.statfs = erofs_statfs,
-	.show_options = erofs_show_options,
-};
+	const struct super_operations erofs_sops = {
+		.put_super = erofs_put_super,
+		.alloc_inode = erofs_alloc_inode,
+		.free_inode = erofs_free_inode,
+		.statfs = erofs_statfs,
+		.show_options = erofs_show_options,
+	};
 
-module_init(erofs_module_init);
-module_exit(erofs_module_exit);
+	module_init(erofs_module_init);
+	module_exit(erofs_module_exit);
 
-MODULE_DESCRIPTION("Enhanced ROM File System");
-MODULE_AUTHOR("Gao Xiang, Chao Yu, Miao Xie, CONSUMER BG, HUAWEI Inc.");
-MODULE_LICENSE("GPL");
+	MODULE_DESCRIPTION("Enhanced ROM File System");
+	MODULE_AUTHOR("Gao Xiang, Chao Yu, Miao Xie, CONSUMER BG, HUAWEI Inc.");
+	MODULE_LICENSE("GPL");
+}
-- 
2.21.1 (Apple Git-122.3)

